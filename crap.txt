мэнэйдж каунт айтэмс

# -*- coding: utf-8 -*-

"""
Модуль отслеживает количество предметов на dota.money аккаунтах. Чистит в случае переполнения оных.
Также перносит предметы, которые стали недоступны (unavailable) для обмена на сайте.

"""
import logging
import time
import traceback
from argparse import ArgumentParser

from exchange import Exchange
from inventory.inventory import inventory_wrapper
from item_types import ItemType
from others import Database
from steam.shared import fetch_waiting_assets, DOTA_APPID
from validation.validation import Validation


class StorageNotFound(Exception):
    pass


class Account(object):
    def __init__(self, steamid, steamid64, tradelink):
        self.steamid = steamid
        self.steamid64 = steamid64
        self.tradelink = tradelink


class Storage(object):
    count_items_limit = 8000
    wealthy_limit = 8000

    def __init__(self, steamid, count_items, wealthy):
        self.steamid = steamid
        self.count_items = count_items
        self.wealthy = wealthy


    def __repr__(self):
        return "steamid={} count_items={} wealthy={}".format(self.steamid, self.count_items, self.wealthy)


    def __gt__(self, other):
        return self.count_items + self.wealthy > other.count_items + other.wealthy


    def add_items(self, additional_items, additional_wealthy):
        self.count_items += additional_items
        self.wealthy += int(additional_wealthy)


def _fetch_storages():
    with Database() as database:
        trashmans = database.query(
            "SELECT steamid64, steamid, money "
            "FROM state.control "
            "WHERE work=5 AND game='Dota' AND state='Trashman' AND money<{}  "
            "".format(Storage.wealthy_limit)
        )
        trashmans_frm = ", ".join([str(steamid64) for steamid64, _, _ in trashmans])

        # Не используем HAVING, потому что пустые трешмены тоже должны быть получены
        storage_items_rate = database.query(
            "SELECT steamid64,COUNT(*) as cnt "
            "FROM inventories.`570` "
            "WHERE steamid64 IN ({}) "
            "GROUP BY steamid64 "
            "ORDER BY cnt ASC".format(trashmans_frm)
        )
        storage_items_rate = {str(steamid64): count_items for steamid64, count_items in storage_items_rate}

    storages = []
    for steamid64, steamid, wealthy in trashmans:
        count_items = storage_items_rate.get(steamid64, 0)
        if count_items < Storage.count_items_limit:
            storages.append(Storage(steamid, count_items, wealthy))

    storages.sort()
    return storages


def choose_storage(count_transfer, storages=None, additional_wealthy=0.0):
    if not storages:
        storages = _fetch_storages()

    count_transfer = min(count_transfer, Limits.count_items_per_offer * Limits.max_count_offers)

    for storage in storages:
        if storage.count_items + count_transfer <= Storage.count_items_limit:
            storage.add_items(count_transfer, additional_wealthy)
            chosen_steamid = storage.steamid
            break
    else:
        raise StorageNotFound("Not found free storage for count_transfer={}".format(count_transfer))

    storages.sort()
    return chosen_steamid



class Limits(object):
    items_limit = 4000
    count_items_per_offer = 30
    additional_cleanup = 250
    max_count_offers = 5


    def __init__(self):
        self.appid = DOTA_APPID
        self.storages = list()

        self.database = Database(commit=True)
        self.exchange = Exchange()
        self.inventory = inventory_wrapper({'appid': self.appid})  # Кешируем тяжелый объект
        self.validation = Validation()


    def manage_inventory(self, account):
        logging.info("Manage inventory steamid={}".format(account.steamid))
        self.inventory.set_steamid64(account.steamid64)
        self.inventory.get_any_inventory_by_proxies()

        self.inventory.insert_into_mysql()
        self.inventory.insert_into_postgresql()

        self.inventory.remove_hidden_assets()


    def choose_assets(self, count_transfer):
        waiting_assetids = fetch_waiting_assets(self.inventory.steamid64, database=self.database, appid=self.appid)
        assets, unavaiables_counter = {}, 0

        for assetid, item_data in self.inventory.get_inventory().items():
            if assetid not in waiting_assetids:
                if item_data['rate'] == ItemType.unavailable:
                    unavaiables_counter += 1

                price = round(item_data['price'], 2)
                assets.update({assetid: price})

        require_transfer = unavaiables_counter
        if count_transfer > 0:
            require_transfer += count_transfer + Limits.additional_cleanup

        assets = sorted(assets.items(), key=lambda x: x[1])[:require_transfer]
        total_price = sum(price for assetid, price in assets)

        return [str(assetid) for assetid, price in assets], total_price


    def manage_count_items(self, account):
        """Если количество скинов на ботах приемлимое, просто проверяем на unavailable."""
        require_transfer = max(self.inventory.get_count_items() - Limits.items_limit, 0)

        account_assets, additional_wealthy = self.choose_assets(require_transfer)

        if account_assets:
            storage_steamid = choose_storage(require_transfer, self.storages, additional_wealthy)
            logging.info("Transfer count_skins={} storage={}".format(len(account_assets), storage_steamid))

            kwargs = {
                "appid": self.appid,
                "count_items_per_offer": Limits.count_items_per_offer,
                "steamid_from": storage_steamid,
                "steamid_to": account.steamid,
                "items_from": [],
                "items_to": ["{}:{}".format(DOTA_APPID, assetid) for assetid in account_assets[:(Limits.count_items_per_offer * Limits.max_count_offers)]],
                "tradelink": account.tradelink,
                "steamid64_to": account.steamid64
            }

            try:
                self.exchange.multiple_make_exchange(**kwargs)
            except AttributeError:
                logging.exception(traceback.format_exc())


    def get_accounts(self):
        with Database(commit=True) as database:
            accounts = database.query(
                "SELECT steamid,steamid64,tradelink "
                "FROM state.control "
                "WHERE work=5 AND state='Dotamoney' AND stateTrader>0 "
                "ORDER BY id ASC "
            )

        return [Account(*args) for args in accounts]


    def run(self):
        for account in self.get_accounts():
            try:
                self.manage_inventory(account)
            except Exception:
                logging.exception(traceback.format_exc())
                continue

            self.manage_count_items(account)

        else:
            time.sleep(60 * 4)



if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument("appid", choices=[DOTA_APPID], type=int, help="Steam game id")
    parser.parse_args()

    Limits().run()
